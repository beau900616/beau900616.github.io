<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>靜態公車偵測器（純前端）</title>
  <style>
    :root{font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial;}
    body{max-width:980px;margin:24px auto;padding:16px;line-height:1.5;color:#111}
    h1{font-size:1.25rem;margin-bottom:8px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    #canvasWrap{position:relative;display:inline-block;border:1px solid #ddd}
    canvas{display:block;max-width:100%;height:auto}
    #message{margin-top:10px}
    .badge{background:#f3f4f6;padding:6px 10px;border-radius:6px;font-size:0.9rem}
    .overlay{position:absolute;left:0;top:0;pointer-events:none}
    .footer{margin-top:18px;font-size:0.9rem;color:#555}
    button{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
    button:disabled{opacity:0.5;cursor:not-allowed}
    input[type=file]{display:block}
    label{font-size:0.95rem}
  </style>
</head>
<body>
  <h1>靜態公車偵測器（純前端、無後端）</h1>
  <p>說明：此頁面使用在地執行的預訓練模型（COCO-SSD via TensorFlow.js）於使用者端辨識影像中是否有「bus」。上傳照片後會在圖片上以方框與信心分數標示所有偵測到的公車，若未偵測到則顯示目前沒有公車。</p>

  <div class="controls">
    <div>
      <label for="imageInput">上傳照片：</label><br />
      <input id="imageInput" type="file" accept="image/*" />
    </div>
    <div>
      <label for="threshold">信心門檻：</label><br />
      <input id="threshold" type="range" min="0" max="100" value="50" />
      <div class="badge">目前：<span id="thresholdVal">0.50</span></div>
    </div>
    <div>
      <button id="runBtn" disabled>執行偵測</button>
      <button id="downloadBtn" disabled>下載標註圖</button>
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="canvas"></canvas>
  </div>

  <div id="message" class="badge">模型載入中，請稍候…</div>

  <div class="footer">
    技術備註：使用 <code>@tensorflow/tfjs</code> 與 <code>@tensorflow-models/coco-ssd</code>（純瀏覽器端）。所有推論在使用者裝置上執行，沒有任何影像會被上傳到伺服器。
  </div>

  <!-- Scripts: TensorFlow.js 與 COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

  <script>
    // 簡潔易維護的模組化程式碼
    (function(){
      const fileInput = document.getElementById('imageInput');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const messageEl = document.getElementById('message');
      const runBtn = document.getElementById('runBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const thresholdRange = document.getElementById('threshold');
      const thresholdVal = document.getElementById('thresholdVal');

      let model = null;
      let currentImage = null; // HTMLImageElement

      const MAX_DIM = 1280; // 尺寸限制，避免在低端裝置耗盡記憶體

      function setMessage(txt){ messageEl.textContent = txt; }

      // 載入模型
      async function loadModel(){
        try{
          setMessage('載入模型中（大約 1-6 秒，視網路與裝置而定）…');
          model = await cocoSsd.load();
          setMessage('模型已載入，請上傳照片然後點「執行偵測」。');
          runBtn.disabled = false;
        }catch(e){
          console.error(e);
          setMessage('模型載入失敗，請檢查網路或重整頁面。');
        }
      }

      // 將 File / Blob 轉成 Image 元件，並限制最大尺寸
      function fileToImage(file){
        return new Promise((resolve,reject)=>{
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            // 若圖片太大，先在 canvas 上縮放再回傳一個新的 Image（保留比例）
            const {width, height} = img;
            let targetW = width, targetH = height;
            if(Math.max(width, height) > MAX_DIM){
              const scale = MAX_DIM / Math.max(width, height);
              targetW = Math.round(width * scale);
              targetH = Math.round(height * scale);
              const tmp = document.createElement('canvas');
              tmp.width = targetW; tmp.height = targetH;
              const tctx = tmp.getContext('2d');
              tctx.drawImage(img, 0,0, targetW, targetH);
              const scaledUrl = tmp.toDataURL('image/jpeg');
              const scaledImg = new Image();
              scaledImg.onload = () => { URL.revokeObjectURL(url); resolve(scaledImg); };
              scaledImg.onerror = reject;
              scaledImg.src = scaledUrl;
            }else{
              URL.revokeObjectURL(url);
              resolve(img);
            }
          };
          img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
          img.src = url;
        });
      }

      // 將圖放到 canvas 上並調整 canvas 大小
      function drawImageToCanvas(img){
        canvas.width = img.naturalWidth || img.width;
        canvas.height = img.naturalHeight || img.height;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0,canvas.width,canvas.height);
      }

      // 在 canvas 上畫框與標籤
      function drawDetections(detections, confThreshold){
        // 先把原圖再畫一次（已畫於 drawImageToCanvas）
        ctx.lineWidth = Math.max(2, Math.floor(canvas.width/300));
        ctx.font = `${Math.max(12, Math.floor(canvas.width/60))}px Arial`;
        detections.forEach(d => {
          if(d.score < confThreshold) return;
          if(d.class !== 'bus') return; // 只顯示公車
          const [x,y,w,h] = d.bbox; // COCO-SSD 的 bbox 格式
          // 框
          ctx.strokeStyle = 'red';
          ctx.strokeRect(x, y, w, h);
          // 標籤背景
          const text = `${d.class} ${(d.score*100).toFixed(1)}%`;
          const textWidth = ctx.measureText(text).width;
          const textHeight = parseInt(ctx.font,10) + 6;
          ctx.fillStyle = 'rgba(255,0,0,0.75)';
          ctx.fillRect(x, Math.max(0,y-textHeight), textWidth + 8, textHeight);
          // 標籤文字
          ctx.fillStyle = 'white';
          ctx.fillText(text, x + 4, Math.max(0,y-4));
        });
      }

      // 執行偵測主流程
      async function runDetection(){
        if(!model) { setMessage('模型尚未載入'); return; }
        if(!currentImage) { setMessage('請先上傳圖片'); return; }
        setMessage('偵測中……');
        // 將影像繪製到 canvas，並送入模型偵測（COCO-SSD 接受 HTMLImageElement / HTMLCanvasElement）
        drawImageToCanvas(currentImage);
        try{
          const predictions = await model.detect(currentImage);
          const conf = Number(thresholdRange.value)/100;
          // 篩選 bus
          const buses = predictions.filter(p => p.class === 'bus' && p.score >= conf);
          if(buses.length === 0){
            setMessage('目前沒有偵測到公車。');
          }else{
            setMessage(`偵測到 ${buses.length} 輛公車（依序顯示分數），紅框為標註。`);
          }
          // 把所有偵測結果（包含非 bus）畫出，但 drawDetections 內又只畫 bus
          drawDetections(predictions, conf);
          downloadBtn.disabled = false;
        }catch(e){
          console.error(e);
          setMessage('偵測失敗，請查看瀏覽器主控台以取得細節。');
        }
      }

      // 下載標註後的圖片
      function downloadAnnotated(){
        const link = document.createElement('a');
        link.download = 'annotated_bus.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      }

      // 事件綁定
      fileInput.addEventListener('change', async (ev)=>{
        const f = ev.target.files && ev.target.files[0];
        if(!f) return;
        runBtn.disabled = true;
        downloadBtn.disabled = true;
        setMessage('讀取影像並處理中…');
        try{
          const img = await fileToImage(f);
          currentImage = img;
          drawImageToCanvas(img);
          setMessage('影像已載入。按「執行偵測」開始。');
          runBtn.disabled = false;
        }catch(e){
          console.error(e);
          setMessage('讀取影像失敗，請嘗試不同的檔案或重新整理頁面。');
        }
      });

      runBtn.addEventListener('click', async ()=>{ runBtn.disabled = true; await runDetection(); runBtn.disabled = false; });
      downloadBtn.addEventListener('click', downloadAnnotated);

      thresholdRange.addEventListener('input', ()=>{ thresholdVal.textContent = (Number(thresholdRange.value)/100).toFixed(2); });

      // 初始化
      thresholdVal.textContent = (Number(thresholdRange.value)/100).toFixed(2);
      loadModel();

    })();
  </script>
</body>
</html>
