<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>印章辨識 YOLOv8n</title>
  <style>
    body {
      font-family: "Noto Sans TC", Arial, sans-serif;
      margin: 20px;
      background: #fafafa;
    }
    h2 { color: #333; }
    input[type="file"] { margin: 15px 0; }
    #preview {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.1/dist/ort.min.js"></script>
  <script src="best_model_b64.js"></script>
</head>
<body>
  <h2>印章辨識 YOLOv8n (前端推論版)</h2>
  <p>請上傳 JPG 或 PNG 檔案，可多選：</p>
  <input type="file" id="imageInput" accept=".jpg,.jpeg,.png" multiple />
  <div id="preview"></div>

<script>
let session;

// === 初始化模型 ===
async function loadModel() {
  console.log("載入 YOLOv8 模型中...");
  // 將 base64 還原成二進位 ArrayBuffer
  const binary = Uint8Array.from(atob(modelBase64), c => c.charCodeAt(0));
  session = await ort.InferenceSession.create(binary.buffer, {
    executionProviders: ['wasm']
  });
  console.log("模型載入完成 ✅");
}

// === 圖片轉 Tensor ===
async function imageToTensor(img) {
  const size = 640; // 與訓練 imgsz 一致
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = size;
  canvas.height = size;
  ctx.drawImage(img, 0, 0, size, size);
  const imgData = ctx.getImageData(0, 0, size, size);
  const data = imgData.data;
  const floatData = new Float32Array(size * size * 3);

  // 將像素轉成 [1,3,H,W] 並正規化至 [0,1]
  let idx = 0;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i] / 255.0;
    const g = data[i + 1] / 255.0;
    const b = data[i + 2] / 255.0;
    const pixelIndex = i / 4;
    const row = Math.floor(pixelIndex / size);
    const col = pixelIndex % size;
    const offset = row * size + col;
    floatData[offset] = r;
    floatData[offset + size * size] = g;
    floatData[offset + 2 * size * size] = b;
  }

  return new ort.Tensor('float32', floatData, [1, 3, size, size]);
}

// === 推論函式 ===
async function detect(img, canvas) {
  const tensor = await imageToTensor(img);
  const output = await session.run({ images: tensor });
  const key = Object.keys(output)[0];
  const out = output[key];
  const data = out.data;
  const shape = out.dims; // [1,84,8400]
  console.log("模型輸出 shape:", shape);

  const numClass = 1; // 你的模型只有「印章」
  const numPred = shape[2];
  const numFeat = shape[1];

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "red";
  ctx.fillStyle = "red";
  ctx.lineWidth = 2;
  ctx.font = "14px sans-serif";

  for (let i = 0; i < numPred; i++) {
    const cx = data[i];
    const cy = data[numPred + i];
    const w  = data[2 * numPred + i];
    const h  = data[3 * numPred + i];
    let bestConf = 0;

    // 找出最大分類信心
    for (let c = 4; c < numFeat; c++) {
      bestConf = Math.max(bestConf, data[c * numPred + i]);
    }

    if (bestConf > 0.5) {
      const x = cx - w / 2;
      const y = cy - h / 2;
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.stroke();
      ctx.fillText(`Seal ${(bestConf * 100).toFixed(1)}%`, x, y - 5);
    }
  }
}


// === 上傳圖片處理 ===
document.getElementById("imageInput").addEventListener("change", async e => {
  const files = [...e.target.files];
  const preview = document.getElementById("preview");
  preview.innerHTML = "";

  for (const file of files) {
    if (!file.type.startsWith("image/")) continue;
    const img = new Image();
    img.src = URL.createObjectURL(file);
    await img.decode();

    const canvas = document.createElement("canvas");
    canvas.width = 640;
    canvas.height = 640;
    preview.appendChild(canvas);

    await detect(img, canvas);
  }
});

loadModel();

</script>
</body>
</html>
